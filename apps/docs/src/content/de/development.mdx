export const metadata = {
  title: 'Entwicklung',
  description:
    'Richten Sie pnpm-catalog-updates fÃ¼r die Entwicklung ein. Lernen Sie die Projektstruktur, den Entwicklungsworkflow und wie Sie beitragen kÃ¶nnen.',
};

# Entwicklung

Richten Sie PCU fÃ¼r die Entwicklung ein und lernen Sie, wie Sie zum Projekt beitragen kÃ¶nnen. Diese Anleitung behandelt Projektsetup, Architektur und Entwicklungsworkflows. {{ className: 'lead' }}

## Voraussetzungen

Bevor Sie mit der PCU-Entwicklung beginnen, stellen Sie sicher, dass Sie die erforderlichen Tools haben:

<Note>Node.js >= 22.0.0 und pnpm >= 10.0.0 sind fÃ¼r die Entwicklung erforderlich.</Note>

<CodeGroup>

```bash {{ title: 'Versionen prÃ¼fen' }}
node --version  # Sollte >= 22.0.0 sein
pnpm --version  # Sollte >= 10.0.0 sein
```

```bash {{ title: 'Tools installieren' }}
# Node.js Ã¼ber nvm installieren (empfohlen)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 22
nvm use 22

# pnpm installieren
npm install -g pnpm@latest
```

</CodeGroup>

## Projekt-Setup

Klonen und Entwicklungsumgebung einrichten:

<CodeGroup>

```bash {{ title: 'Klonen und Setup' }}
# Repository klonen
git clone https://github.com/houko/pnpm-catalog-updates.git
cd pnpm-catalog-updates

# Dependencies installieren
pnpm install

# Projekt bauen
pnpm build

# Tests ausfÃ¼hren um Setup zu verifizieren
pnpm test
```

```bash {{ title: 'Entwicklungsmodus' }}
# Im Entwicklungsmodus ausfÃ¼hren
pnpm dev --help

# Im Watch-Modus bauen
pnpm build:watch

# Tests im Watch-Modus ausfÃ¼hren
pnpm test:watch
```

</CodeGroup>

## Projektarchitektur

PCU folgt Clean Architecture-Prinzipien mit klarer Trennung der Belange:

```text
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ cli/                    # CLI-Anwendungsschicht
â”‚   â”‚   â”œâ”€â”€ src/cli/           # CLI-Interface
â”‚   â”‚   â”‚   â”œâ”€â”€ commands/      # Befehlshandler
â”‚   â”‚   â”‚   â”œâ”€â”€ formatters/    # Ausgabe-Formatierer
â”‚   â”‚   â”‚   â”œâ”€â”€ interactive/   # Interaktive Prompts
â”‚   â”‚   â”‚   â”œâ”€â”€ themes/        # Farbthemen
â”‚   â”‚   â”‚   â””â”€â”€ validators/    # Eingabe-Validierung
â”‚   â”‚   â””â”€â”€ bin/               # AusfÃ¼hrbare BinÃ¤rdateien
â”‚   â””â”€â”€ docs/                  # Dokumentations-Website
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ core/                  # Kern-GeschÃ¤ftslogik
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ application/   # Anwendungsservices
â”‚   â”‚       â”œâ”€â”€ domain/        # Domain-Modell (DDD)
â”‚   â”‚       â””â”€â”€ infrastructure/# Infrastruktur-Schicht
â”‚   â””â”€â”€ utils/                 # Geteilte Hilfsprogramme
â””â”€â”€ scripts/                   # Build- und Deployment-Skripte
```

### Architektur-Schichten

<Properties>
  <Property name="CLI-Schicht" type="apps/cli">
    BenutzeroberflÃ¤che, Befehlsanalyse, Ausgabe-Formatierung
  </Property>
  <Property name="Anwendungsschicht" type="packages/core/application">
    GeschÃ¤ftslogik-Orchestrierung, AnwendungsfÃ¤lle
  </Property>
  <Property name="Domain-Schicht" type="packages/core/domain">
    Kern-GeschÃ¤ftsentitÃ¤ten, Value Objects, Repository-Interfaces
  </Property>
  <Property name="Infrastruktur-Schicht" type="packages/core/infrastructure">
    Externe API-Clients, Dateisystem-Zugriff, Repository-Implementierungen
  </Property>
  <Property name="Utils-Schicht" type="packages/utils">
    Geteilte Hilfsprogramme, Konfiguration, Logging, Fehlerbehandlung
  </Property>
</Properties>

## Entwicklungsworkflow

### Ã„nderungen vornehmen

1. **Feature-Branch erstellen**:

   ```bash
   git checkout -b feature/amazing-feature
   ```

2. **Ã„nderungen vornehmen** entsprechend den Coding Standards

3. **Tests fÃ¼r Ihre Ã„nderungen hinzufÃ¼gen**:

   ```bash
   pnpm test:watch  # Tests im Watch-Modus ausfÃ¼hren
   ```

4. **QualitÃ¤tsprÃ¼fungen bestehen lassen**:

   ```bash
   pnpm lint        # Code-Stil prÃ¼fen
   pnpm typecheck   # Typ-ÃœberprÃ¼fung
   pnpm test        # Alle Tests ausfÃ¼hren
   ```

5. **Ã„nderungen committen**:
   ```bash
   git commit -m 'feat: add amazing feature'
   ```

### Test-Strategie

PCU verwendet einen umfassenden Test-Ansatz:

<CodeGroup>

```bash {{ title: 'Unit Tests' }}
# Unit Tests ausfÃ¼hren
pnpm test

# Mit Coverage ausfÃ¼hren
pnpm test:coverage

# Spezifisches Paket testen
pnpm --filter @pcu/core test
```

```bash {{ title: 'E2E Tests' }}
# End-to-End-Tests ausfÃ¼hren
pnpm test:e2e

# Gegen echte Projekte testen
pnpm test:e2e --project example-workspace
```

```bash {{ title: 'Integrationstests' }}
# CLI-Befehle testen
pnpm test:cli

# Mit verschiedenen Node-Versionen testen
nvm use 18 && pnpm test
nvm use 20 && pnpm test
nvm use 22 && pnpm test
```

</CodeGroup>

### Code-QualitÃ¤t

PCU hÃ¤lt hohe Code-QualitÃ¤tsstandards aufrecht:

<CodeGroup>

```bash {{ title: 'Linting und Formatierung' }}
# Code-Stil prÃ¼fen
pnpm lint

# Linting-Probleme beheben
pnpm lint:fix

# Code formatieren
pnpm format

# TypeScript-Typen prÃ¼fen
pnpm typecheck
```

```json {{ title: 'QualitÃ¤tsstandards' }}
{
  "coverage": {
    "statements": 85,
    "branches": 80,
    "functions": 85,
    "lines": 85
  },
  "lint": "ESLint mit TypeScript-Regeln",
  "format": "Prettier mit benutzerdefinierter Konfiguration",
  "types": "Strikte TypeScript-Konfiguration"
}
```

</CodeGroup>

## Features hinzufÃ¼gen

### Neue Befehle erstellen

1. **Befehlshandler erstellen** in `apps/cli/src/cli/commands/`:

<CodeGroup>

```typescript {{ title: 'newCommand.ts' }}
import { Command } from 'commander';
import { GlobalOptions } from '../options';

export function createNewCommand(): Command {
  return new Command('new')
    .description('Beschreibung des neuen Befehls')
    .option('-f, --format <type>', 'Ausgabeformat', 'table')
    .action(async (options: NewCommandOptions) => {
      // Befehlsimplementierung
    });
}

interface NewCommandOptions extends GlobalOptions {
  format: string;
}
```

```typescript {{ title: 'Befehl registrieren' }}
// In apps/cli/src/cli/index.ts
import { createNewCommand } from './commands/newCommand';

program.addCommand(createNewCommand());
```

</CodeGroup>

2. **GeschÃ¤ftslogik hinzufÃ¼gen** in `packages/core/src/application/services/`

3. **Tests erstellen** fÃ¼r sowohl CLI als auch Kern-Logik

4. **Dokumentation aktualisieren**

### Neue Ausgabeformate hinzufÃ¼gen

1. **Formatierer erstellen** in `apps/cli/src/cli/formatters/`:

```typescript {{ title: 'xmlFormatter.ts' }}
import { OutputFormatter, FormattedOutput } from './outputFormatter';

export class XmlFormatter implements OutputFormatter {
  format(data: any): FormattedOutput {
    // XML-Formatierungslogik
    return {
      content: xmlContent,
      type: 'xml',
    };
  }
}
```

2. **Formatierer registrieren** in der Haupt-Formatierer-Registry

3. **Tests hinzufÃ¼gen** und **Dokumentation aktualisieren**

## Beitragsrichtlinien

### Commit-Message-Konvention

PCU verwendet [Conventional Commits](https://conventionalcommits.org/):

<CodeGroup>

```bash {{ title: 'Commit-Typen' }}
feat: Ein neues Feature
fix: Ein Bugfix
docs: Nur DokumentationsÃ¤nderungen
style: Code-Stil-Ã„nderungen (Formatierung, etc.)
refactor: Code-Ã„nderung, die weder Bug behebt noch Feature hinzufÃ¼gt
test: Fehlende Tests hinzufÃ¼gen oder bestehende korrigieren
chore: Ã„nderungen am Build-Prozess oder Hilfswerkzeugen
```

```bash {{ title: 'Beispiele' }}
feat: add support for custom registries
fix: handle network timeouts gracefully
docs: update configuration examples
test: add tests for package filtering
```

</CodeGroup>

### Pull Request-Prozess

1. **Repository forken** und Feature-Branch erstellen
2. **Ã„nderungen vornehmen** entsprechend dem Entwicklungsworkflow
3. **Alle Tests bestehen lassen** und Code-QualitÃ¤tsprÃ¼fungen erfolgreich
4. **Dokumentation aktualisieren** falls nÃ¶tig
5. **Pull Request einreichen** mit:
   - Klarer Beschreibung der Ã„nderungen
   - Link zu verwandten Issues
   - Screenshots fÃ¼r UI-Ã„nderungen
   - Breaking Change-Notizen falls zutreffend

### Code Review-Checkliste

1. Alle Tests bestehen
2. Code-Coverage aufrechterhalten (>85%)
3. TypeScript-Typen sind korrekt
4. Code-Stil folgt Projekt-Standards
5. Dokumentation aktualisiert
6. Breaking Changes dokumentiert
7. Performance-Auswirkung berÃ¼cksichtigt

## Debugging

### Entwicklungs-Debugging

<CodeGroup>

```bash {{ title: 'CLI-Befehle debuggen' }}
# Mit Node.js Inspector debuggen
node --inspect-brk ./apps/cli/bin/pcu.js --help

# Mit VS Code debuggen
# Verwenden Sie die Launch-Konfiguration in .vscode/launch.json
```

```bash {{ title: 'AusfÃ¼hrliche Protokollierung' }}
# Debug-Logging aktivieren
DEBUG=pcu:* pnpm dev --verbose

# Spezifische Module debuggen
DEBUG=pcu:core,pcu:cli pcu -c
```

</CodeGroup>

### Test-Debugging

```bash
# Spezifischen Test debuggen
npm test -- --grep "specific test name"

# Mit Node Inspector debuggen
node --inspect-brk node_modules/.bin/vitest run
```

## Bauen und VerÃ¶ffentlichen

### Lokale Tests

<CodeGroup>

```bash {{ title: 'Lokalen Build testen' }}
# Lokal bauen und testen
pnpm build
pnpm --filter @pcu/cli start --help

# Installation testen
npm pack apps/cli
npm install -g pcu-*.tgz
```

```bash {{ title: 'In Beispielprojekt testen' }}
# Beispiel-Workspace verwenden
cd apps/example
pcu -c
pcu -u --dry-run
```

</CodeGroup>

### Release-Prozess

1. **Version aktualisieren** mit Changesets:

   ```bash
   pnpm changeset
   pnpm changeset version
   ```

2. **Bauen und testen**:

   ```bash
   pnpm build
   pnpm test
   pnpm test:e2e
   ```

3. **VerÃ¶ffentlichen** (nur Maintainer):
   ```bash
   pnpm publish -r
   ```

## Hilfe erhalten

- ğŸ“– **Dokumentation**: PrÃ¼fen Sie diese Dokumentation fÃ¼r detaillierte Anleitungen
- ğŸ› **Issues**: Melden Sie Bugs Ã¼ber [GitHub Issues](https://github.com/houko/pnpm-catalog-updates/issues)
- ğŸ’¬ **Diskussionen**: Stellen Sie Fragen in [GitHub Discussions](https://github.com/houko/pnpm-catalog-updates/discussions)
- ğŸ”§ **Entwicklung**: Nehmen Sie an Entwicklungsdiskussionen in Issues und PRs teil

---

## Erweiterte Architektur-Details

### Kern-Domain-Modell

Basierend auf Domain-Driven Design (DDD)-Prinzipien umfasst PCUs Kern-Domain:

<CodeGroup>

```typescript {{ title: 'Domain-EntitÃ¤ten' }}
// packages/core/src/domain/entities/
â”œâ”€â”€ catalog.ts          // Catalog Aggregate Root
â”œâ”€â”€ package.ts          // Package-EntitÃ¤t
â””â”€â”€ workspace.ts        // Workspace Aggregate Root

// Zentrale Domain-Konzepte:
interface Catalog {
  readonly id: CatalogId;
  readonly name: string;
  packages: PackageCollection;
  addPackage(packageInfo: Package): void;
  updatePackage(name: string, version: Version): void;
}

interface Package {
  readonly name: string;
  readonly currentVersion: Version;
  readonly latestVersion: Version;
  readonly updateType: UpdateType;
}
```

```typescript {{ title: 'Value Objects' }}
// packages/core/src/domain/value-objects/
â”œâ”€â”€ version.ts           // Semantic Version-Behandlung
â”œâ”€â”€ workspacePath.ts     // Pfad-Validierung
â”œâ”€â”€ workspaceConfig.ts   // Konfigurationsobjekt
â””â”€â”€ catalogCollection.ts // Collection-Management

// UnverÃ¤nderliche Value Objects gewÃ¤hrleisten DatenintegritÃ¤t
class Version {
  constructor(private readonly value: string) {
    if (!this.isValid(value)) {
      throw new InvalidVersionError(value);
    }
  }

  toString(): string { return this.value; }
  compare(other: Version): number { /* semver-Vergleich */ }
}
```

</CodeGroup>

### Service-Schicht-Architektur

Die Anwendungsschicht orchestriert GeschÃ¤ftslogik durch Services:

<CodeGroup>

```typescript {{ title: 'Anwendungsservices' }}
// packages/core/src/application/services/
â”œâ”€â”€ catalogUpdateService.ts  // Haupt-Orchestrierung
â””â”€â”€ workspaceService.ts      // Workspace-Operationen

// Service-Verantwortlichkeiten:
class CatalogUpdateService {
  async checkForUpdates(options: CheckOptions): Promise<UpdateReport>;
  async updateCatalog(options: UpdateOptions): Promise<UpdateResult>;
  async analyzeImpact(catalog: string, package: string): Promise<ImpactAnalysis>;
}
```

```typescript {{ title: 'Infrastruktur-Schicht' }}
// packages/core/src/infrastructure/
â”œâ”€â”€ external-services/
â”‚   â””â”€â”€ npmRegistryService.ts   // NPM-API-Client
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ fileWorkspaceRepository.ts  // Dateisystem-Persistierung
â”œâ”€â”€ cache/
â”‚   â””â”€â”€ cache.ts                # Erweiterte Caching-System
â””â”€â”€ utils/
    â””â”€â”€ npmrcParser.ts          # Konfigurationsanalyse

// Infrastruktur implementiert Domain-Interfaces:
class FileWorkspaceRepository implements WorkspaceRepository {
  async findWorkspace(path: string): Promise<Workspace | null>;
  async saveWorkspace(workspace: Workspace): Promise<void>;
}
```

</CodeGroup>

### CLI-Schicht-Design

Die CLI-Schicht bietet eine saubere Schnittstelle zur Kern-Domain:

<CodeGroup>

```typescript {{ title: 'Befehlsstruktur' }}
// apps/cli/src/cli/commands/
â”œâ”€â”€ checkCommand.ts     // Check-Befehl-Implementierung
â”œâ”€â”€ updateCommand.ts    // Update-Befehl mit Validierung
â”œâ”€â”€ analyzeCommand.ts   // Impact-Analyse-Befehl
â”œâ”€â”€ workspaceCommand.ts # Workspace-Management
â”œâ”€â”€ themeCommand.ts     # Theme-Konfiguration
â”œâ”€â”€ securityCommand.ts  # Sicherheitsscanning
â””â”€â”€ initCommand.ts      # Workspace-Initialisierung

// Jeder Befehl folgt konsistenten Mustern:
export class CheckCommand {
  constructor(
    private readonly catalogService: CatalogUpdateService,
    private readonly validator: CommandValidator,
    private readonly formatter: OutputFormatter
  ) {}

  async execute(options: CheckCommandOptions): Promise<void> {
    const validation = this.validator.validateCheckOptions(options);
    if (!validation.isValid) {
      throw new ValidationError(validation.errors);
    }

    const result = await this.catalogService.checkForUpdates(options);
    const formatted = this.formatter.format(result, options.format);
    console.log(formatted);
  }
}
```

```typescript {{ title: 'Erweiterte CLI-Features' }}
// apps/cli/src/cli/
â”œâ”€â”€ validators/
â”‚   â””â”€â”€ commandValidator.ts    # Eingabe-Validierung mit VorschlÃ¤gen
â”œâ”€â”€ interactive/
â”‚   â””â”€â”€ interactivePrompts.ts  # Intelligente Prompts mit Auto-VervollstÃ¤ndigung
â”œâ”€â”€ themes/
â”‚   â””â”€â”€ colorTheme.ts          # Umfassendes Theming-System
â””â”€â”€ formatters/
    â””â”€â”€ outputFormatter.ts     # Mehrere Ausgabeformate

// Interaktive Features:
class InteractivePrompts {
  async selectPackages(packages: Package[]): Promise<string[]>;
  async confirmUpdates(updates: Update[]): Promise<boolean>;
  async configurationWizard(): Promise<Configuration>;
}
```

</CodeGroup>

### Test-Architektur

Umfassende Test-Strategie Ã¼ber alle Schichten:

<CodeGroup>

```bash {{ title: 'Test-Struktur' }}
â”œâ”€â”€ packages/core/src/**/__tests__/     # Unit Tests
â”œâ”€â”€ packages/utils/src/**/__tests__/    # Hilfsprogramm-Tests
â”œâ”€â”€ apps/cli/src/**/__tests__/         # CLI Unit Tests
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ e2e/                          # End-to-End-Tests
â”‚   â”œâ”€â”€ integration/                  # Integrationstests
â”‚   â””â”€â”€ fixtures/                     # Test-Fixtures
â””â”€â”€ .github/workflows/
    â””â”€â”€ test.yml                      # CI-Test-Pipeline
```

```typescript {{ title: 'Test-Muster' }}
// Domain-Schicht-Tests
describe('Catalog', () => {
  it('should update package version', () => {
    const catalog = new Catalog('default');
    const package = new Package('react', '18.0.0', '18.2.0');

    catalog.addPackage(package);
    catalog.updatePackage('react', new Version('18.2.0'));

    expect(catalog.getPackage('react').currentVersion.toString()).toBe('18.2.0');
  });
});

// CLI-Integrationstests
describe('CheckCommand', () => {
  it('should handle network errors gracefully', async () => {
    const mockService = createMockCatalogService();
    mockService.checkForUpdates.mockRejectedValue(new NetworkError());

    const command = new CheckCommand(mockService);

    await expect(command.execute({})).rejects.toThrow('Network error occurred');
  });
});
```

</CodeGroup>

### Performance-Ãœberlegungen

PCU ist fÃ¼r Performance in groÃŸen Monorepos optimiert:

<CodeGroup>

```typescript {{ title: 'Caching-Strategie' }}
// Intelligentes Caching reduziert API-Aufrufe
class Cache<T> {
  constructor(
    private readonly options: {
      ttl: number; // Time to live
      maxSize: number; // Speicherlimit
      persistToDisk: boolean; // Datei-Caching
      strategy: 'lru' | 'fifo' | 'lfu'; // Eviction-Strategie
    }
  ) {}

  async get(key: string): Promise<T | null>;
  async set(key: string, value: T): Promise<void>;
  getStats(): CacheStats; // Hit-Raten, Speicherverbrauch
}
```

```typescript {{ title: 'Gleichzeitige Verarbeitung' }}
// Parallele Verarbeitung fÃ¼r bessere Performance
class NpmRegistryService {
  constructor(private readonly concurrency: number = 5) {}

  async getPackageInfo(names: string[]): Promise<PackageInfo[]> {
    // Pakete in Batches mit kontrollierter Gleichzeitigkeit verarbeiten
    const batches = chunk(names, this.concurrency);
    const results = await Promise.allSettled(batches.map((batch) => this.processBatch(batch)));

    return results.flatMap((result) => (result.status === 'fulfilled' ? result.value : []));
  }
}
```

</CodeGroup>
