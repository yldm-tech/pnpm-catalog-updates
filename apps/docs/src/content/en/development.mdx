export const metadata = {
  title: 'Development',
  description:
    'Set up pnpm-catalog-updates for development. Learn about the project structure, development workflow, and how to contribute.',
};

# Development

Set up PCU for development and learn how to contribute to the project. This guide covers project setup, architecture, and development workflows. {{ className: 'lead' }}

## Prerequisites

Before you start developing PCU, make sure you have the required tools:

<Note>Node.js >= 22.0.0 and pnpm >= 10.0.0 are required for development.</Note>

<CodeGroup>

```bash {{ title: 'Check Versions' }}
node --version  # Should be >= 22.0.0
pnpm --version  # Should be >= 10.0.0
```

```bash {{ title: 'Install Tools' }}
# Install Node.js via nvm (recommended)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 22
nvm use 22

# Install pnpm
npm install -g pnpm@latest
```

</CodeGroup>

## Project Setup

Clone and set up the development environment:

<CodeGroup>

```bash {{ title: 'Clone and Setup' }}
# Clone the repository
git clone https://github.com/houko/pnpm-catalog-updates.git
cd pnpm-catalog-updates

# Install dependencies
pnpm install

# Build the project
pnpm build

# Run tests to verify setup
pnpm test
```

```bash {{ title: 'Development Mode' }}
# Run in development mode
pnpm dev --help

# Build in watch mode
pnpm build:watch

# Run tests in watch mode
pnpm test:watch
```

</CodeGroup>

## Project Architecture

PCU follows clean architecture principles with clear separation of concerns:

```text
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ cli/                    # CLI application layer
â”‚   â”‚   â”œâ”€â”€ src/cli/           # CLI interface
â”‚   â”‚   â”‚   â”œâ”€â”€ commands/      # Command handlers
â”‚   â”‚   â”‚   â”œâ”€â”€ formatters/    # Output formatters
â”‚   â”‚   â”‚   â”œâ”€â”€ interactive/   # Interactive prompts
â”‚   â”‚   â”‚   â”œâ”€â”€ themes/        # Color themes
â”‚   â”‚   â”‚   â””â”€â”€ validators/    # Input validation
â”‚   â”‚   â””â”€â”€ bin/               # Executable binaries
â”‚   â””â”€â”€ docs/                  # Documentation site
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ core/                  # Core business logic
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ application/   # Application services
â”‚   â”‚       â”œâ”€â”€ domain/        # Domain model (DDD)
â”‚   â”‚       â””â”€â”€ infrastructure/# Infrastructure layer
â”‚   â””â”€â”€ utils/                 # Shared utilities
â””â”€â”€ scripts/                   # Build and deployment
```

### Architecture Layers

<Properties>
  <Property name="CLI Layer" type="apps/cli">
    User interface, command parsing, output formatting
  </Property>
  <Property name="Application Layer" type="packages/core/application">
    Business logic orchestration, use cases
  </Property>
  <Property name="Domain Layer" type="packages/core/domain">
    Core business entities, value objects, repository interfaces
  </Property>
  <Property name="Infrastructure Layer" type="packages/core/infrastructure">
    External API clients, file system access, repository implementations
  </Property>
  <Property name="Utils Layer" type="packages/utils">
    Shared utilities, configuration, logging, error handling
  </Property>
</Properties>

## Development Workflow

### Making Changes

1. **Create a feature branch**:

   ```bash
   git checkout -b feature/amazing-feature
   ```

2. **Make your changes** following the coding standards

3. **Add tests** for your changes:

   ```bash
   pnpm test:watch  # Run tests in watch mode
   ```

4. **Ensure quality checks pass**:

   ```bash
   pnpm lint        # Check code style
   pnpm typecheck   # Type checking
   pnpm test        # Run all tests
   ```

5. **Commit your changes**:
   ```bash
   git commit -m 'feat: add amazing feature'
   ```

### Testing Strategy

PCU uses a comprehensive testing approach:

<CodeGroup>

```bash {{ title: 'Unit Tests' }}
# Run unit tests
pnpm test

# Run with coverage
pnpm test:coverage

# Test specific package
pnpm --filter @pcu/core test
```

```bash {{ title: 'E2E Tests' }}
# Run end-to-end tests
pnpm test:e2e

# Test against real projects
pnpm test:e2e --project example-workspace
```

```bash {{ title: 'Integration Tests' }}
# Test CLI commands
pnpm test:cli

# Test with different Node versions
nvm use 18 && pnpm test
nvm use 20 && pnpm test
nvm use 22 && pnpm test
```

</CodeGroup>

### Code Quality

PCU maintains high code quality standards:

<CodeGroup>

```bash {{ title: 'Linting and Formatting' }}
# Check code style
pnpm lint

# Fix linting issues
pnpm lint:fix

# Format code
pnpm format

# Check TypeScript types
pnpm typecheck
```

```json {{ title: 'Quality Standards' }}
{
  "coverage": {
    "statements": 85,
    "branches": 80,
    "functions": 85,
    "lines": 85
  },
  "lint": "ESLint with TypeScript rules",
  "format": "Prettier with custom config",
  "types": "Strict TypeScript configuration"
}
```

</CodeGroup>

## Adding Features

### Creating New Commands

1. **Create command handler** in `apps/cli/src/cli/commands/`:

<CodeGroup>

```typescript {{ title: 'newCommand.ts' }}
import { Command } from 'commander';
import { GlobalOptions } from '../options';

export function createNewCommand(): Command {
  return new Command('new')
    .description('Description of new command')
    .option('-f, --format <type>', 'Output format', 'table')
    .action(async (options: NewCommandOptions) => {
      // Command implementation
    });
}

interface NewCommandOptions extends GlobalOptions {
  format: string;
}
```

```typescript {{ title: 'Register Command' }}
// In apps/cli/src/cli/index.ts
import { createNewCommand } from './commands/newCommand';

program.addCommand(createNewCommand());
```

</CodeGroup>

2. **Add business logic** in `packages/core/src/application/services/`

3. **Create tests** for both CLI and core logic

4. **Update documentation**

### Adding New Output Formats

1. **Create formatter** in `apps/cli/src/cli/formatters/`:

```typescript {{ title: 'xmlFormatter.ts' }}
import { OutputFormatter, FormattedOutput } from './outputFormatter';

export class XmlFormatter implements OutputFormatter {
  format(data: any): FormattedOutput {
    // XML formatting logic
    return {
      content: xmlContent,
      type: 'xml',
    };
  }
}
```

2. **Register formatter** in the main formatter registry

3. **Add tests** and **update documentation**

## Contributing Guidelines

### Commit Message Convention

PCU uses [Conventional Commits](https://conventionalcommits.org/):

<CodeGroup>

```bash {{ title: 'Commit Types' }}
feat: A new feature
fix: A bug fix
docs: Documentation only changes
style: Code style changes (formatting, etc)
refactor: Code change that neither fixes a bug nor adds a feature
test: Adding missing tests or correcting existing tests
chore: Changes to build process or auxiliary tools
```

```bash {{ title: 'Examples' }}
feat: add support for custom registries
fix: handle network timeouts gracefully
docs: update configuration examples
test: add tests for package filtering
```

</CodeGroup>

### Pull Request Process

1. **Fork the repository** and create a feature branch
2. **Make your changes** following the development workflow
3. **Ensure all tests pass** and code quality checks succeed
4. **Update documentation** if needed
5. **Submit a pull request** with:
   - Clear description of changes
   - Link to related issues
   - Screenshots for UI changes
   - Breaking change notes if applicable

### Code Review Checklist

1. All tests pass
2. Code coverage maintained (>85%)
3. TypeScript types are correct
4. Code style follows project standards
5. Documentation updated
6. Breaking changes documented
7. Performance impact considered

## Debugging

### Development Debugging

<CodeGroup>

```bash {{ title: 'Debug CLI Commands' }}
# Debug with Node.js inspector
node --inspect-brk ./apps/cli/bin/pcu.js --help

# Debug with VS Code
# Use the launch configuration in .vscode/launch.json
```

```bash {{ title: 'Verbose Logging' }}
# Enable debug logging
DEBUG=pcu:* pnpm dev --verbose

# Debug specific modules
DEBUG=pcu:core,pcu:cli pcu -c
```

</CodeGroup>

### Testing Debugging

```bash
# Debug specific test
npm test -- --grep "specific test name"

# Debug with Node inspector
node --inspect-brk node_modules/.bin/vitest run
```

## Building and Publishing

### Local Testing

<CodeGroup>

```bash {{ title: 'Test Local Build' }}
# Build and test locally
pnpm build
pnpm --filter @pcu/cli start --help

# Test installation
npm pack apps/cli
npm install -g pcu-*.tgz
```

```bash {{ title: 'Test in Example Project' }}
# Use the example workspace
cd apps/example
pcu -c
pcu -u --dry-run
```

</CodeGroup>

### Release Process

1. **Update version** using changesets:

   ```bash
   pnpm changeset
   pnpm changeset version
   ```

2. **Build and test**:

   ```bash
   pnpm build
   pnpm test
   pnpm test:e2e
   ```

3. **Publish** (maintainers only):
   ```bash
   pnpm publish -r
   ```

## Getting Help

- ğŸ“– **Documentation**: Check this documentation for detailed guides
- ğŸ› **Issues**: Report bugs via [GitHub Issues](https://github.com/houko/pnpm-catalog-updates/issues)
- ğŸ’¬ **Discussions**: Ask questions in [GitHub Discussions](https://github.com/houko/pnpm-catalog-updates/discussions)
- ğŸ”§ **Development**: Join development discussions in issues and PRs

---

## Advanced Architecture Details

### Core Domain Model

Based on Domain-Driven Design (DDD) principles, PCU's core domain includes:

<CodeGroup>

```typescript {{ title: 'Domain Entities' }}
// packages/core/src/domain/entities/
â”œâ”€â”€ catalog.ts          // Catalog aggregate root
â”œâ”€â”€ package.ts          // Package entity
â””â”€â”€ workspace.ts        // Workspace aggregate root

// Key domain concepts:
interface Catalog {
  readonly id: CatalogId;
  readonly name: string;
  packages: PackageCollection;
  addPackage(packageInfo: Package): void;
  updatePackage(name: string, version: Version): void;
}

interface Package {
  readonly name: string;
  readonly currentVersion: Version;
  readonly latestVersion: Version;
  readonly updateType: UpdateType;
}
```

```typescript {{ title: 'Value Objects' }}
// packages/core/src/domain/value-objects/
â”œâ”€â”€ version.ts           // Semantic version handling
â”œâ”€â”€ workspacePath.ts     // Path validation
â”œâ”€â”€ workspaceConfig.ts   // Configuration object
â””â”€â”€ catalogCollection.ts // Collection management

// Immutable value objects ensure data integrity
class Version {
  constructor(private readonly value: string) {
    if (!this.isValid(value)) {
      throw new InvalidVersionError(value);
    }
  }

  toString(): string { return this.value; }
  compare(other: Version): number { /* semver comparison */ }
}
```

</CodeGroup>

### Service Layer Architecture

The application layer orchestrates business logic through services:

<CodeGroup>

```typescript {{ title: 'Application Services' }}
// packages/core/src/application/services/
â”œâ”€â”€ catalogUpdateService.ts  // Main orchestration
â””â”€â”€ workspaceService.ts      // Workspace operations

// Service responsibilities:
class CatalogUpdateService {
  async checkForUpdates(options: CheckOptions): Promise<UpdateReport>;
  async updateCatalog(options: UpdateOptions): Promise<UpdateResult>;
  async analyzeImpact(catalog: string, package: string): Promise<ImpactAnalysis>;
}
```

```typescript {{ title: 'Infrastructure Layer' }}
// packages/core/src/infrastructure/
â”œâ”€â”€ external-services/
â”‚   â””â”€â”€ npmRegistryService.ts   // NPM API client
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ fileWorkspaceRepository.ts  // File system persistence
â”œâ”€â”€ cache/
â”‚   â””â”€â”€ cache.ts                # Advanced caching system
â””â”€â”€ utils/
    â””â”€â”€ npmrcParser.ts          # Configuration parsing

// Infrastructure implements domain interfaces:
class FileWorkspaceRepository implements WorkspaceRepository {
  async findWorkspace(path: string): Promise<Workspace | null>;
  async saveWorkspace(workspace: Workspace): Promise<void>;
}
```

</CodeGroup>

### CLI Layer Design

The CLI layer provides a clean interface to the core domain:

<CodeGroup>

```typescript {{ title: 'Command Structure' }}
// apps/cli/src/cli/commands/
â”œâ”€â”€ checkCommand.ts     // Check command implementation
â”œâ”€â”€ updateCommand.ts    // Update command with validation
â”œâ”€â”€ analyzeCommand.ts   // Impact analysis command
â”œâ”€â”€ workspaceCommand.ts # Workspace management
â”œâ”€â”€ themeCommand.ts     # Theme configuration
â”œâ”€â”€ securityCommand.ts  # Security scanning
â””â”€â”€ initCommand.ts      # Workspace initialization

// Each command follows consistent patterns:
export class CheckCommand {
  constructor(
    private readonly catalogService: CatalogUpdateService,
    private readonly validator: CommandValidator,
    private readonly formatter: OutputFormatter
  ) {}

  async execute(options: CheckCommandOptions): Promise<void> {
    const validation = this.validator.validateCheckOptions(options);
    if (!validation.isValid) {
      throw new ValidationError(validation.errors);
    }

    const result = await this.catalogService.checkForUpdates(options);
    const formatted = this.formatter.format(result, options.format);
    console.log(formatted);
  }
}
```

```typescript {{ title: 'Advanced CLI Features' }}
// apps/cli/src/cli/
â”œâ”€â”€ validators/
â”‚   â””â”€â”€ commandValidator.ts    # Input validation with suggestions
â”œâ”€â”€ interactive/
â”‚   â””â”€â”€ interactivePrompts.ts  # Smart prompts with auto-completion
â”œâ”€â”€ themes/
â”‚   â””â”€â”€ colorTheme.ts          # Comprehensive theming system
â””â”€â”€ formatters/
    â””â”€â”€ outputFormatter.ts     # Multiple output formats

// Interactive features:
class InteractivePrompts {
  async selectPackages(packages: Package[]): Promise<string[]>;
  async confirmUpdates(updates: Update[]): Promise<boolean>;
  async configurationWizard(): Promise<Configuration>;
}
```

</CodeGroup>

### Testing Architecture

Comprehensive testing strategy across all layers:

<CodeGroup>

```bash {{ title: 'Test Structure' }}
â”œâ”€â”€ packages/core/src/**/__tests__/     # Unit tests
â”œâ”€â”€ packages/utils/src/**/__tests__/    # Utility tests
â”œâ”€â”€ apps/cli/src/**/__tests__/         # CLI unit tests
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ e2e/                          # End-to-end tests
â”‚   â”œâ”€â”€ integration/                  # Integration tests
â”‚   â””â”€â”€ fixtures/                     # Test fixtures
â””â”€â”€ .github/workflows/
    â””â”€â”€ test.yml                      # CI test pipeline
```

```typescript {{ title: 'Testing Patterns' }}
// Domain layer tests
describe('Catalog', () => {
  it('should update package version', () => {
    const catalog = new Catalog('default');
    const package = new Package('react', '18.0.0', '18.2.0');

    catalog.addPackage(package);
    catalog.updatePackage('react', new Version('18.2.0'));

    expect(catalog.getPackage('react').currentVersion.toString()).toBe('18.2.0');
  });
});

// CLI integration tests
describe('CheckCommand', () => {
  it('should handle network errors gracefully', async () => {
    const mockService = createMockCatalogService();
    mockService.checkForUpdates.mockRejectedValue(new NetworkError());

    const command = new CheckCommand(mockService);

    await expect(command.execute({})).rejects.toThrow('Network error occurred');
  });
});
```

</CodeGroup>

### Performance Considerations

PCU is optimized for performance in large monorepos:

<CodeGroup>

```typescript {{ title: 'Caching Strategy' }}
// Intelligent caching reduces API calls
class Cache<T> {
  constructor(
    private readonly options: {
      ttl: number; // Time to live
      maxSize: number; // Memory limit
      persistToDisk: boolean; // File caching
      strategy: 'lru' | 'fifo' | 'lfu'; // Eviction strategy
    }
  ) {}

  async get(key: string): Promise<T | null>;
  async set(key: string, value: T): Promise<void>;
  getStats(): CacheStats; // Hit rates, memory usage
}
```

```typescript {{ title: 'Concurrent Processing' }}
// Parallel processing for better performance
class NpmRegistryService {
  constructor(private readonly concurrency: number = 5) {}

  async getPackageInfo(names: string[]): Promise<PackageInfo[]> {
    // Process packages in batches with controlled concurrency
    const batches = chunk(names, this.concurrency);
    const results = await Promise.allSettled(batches.map((batch) => this.processBatch(batch)));

    return results.flatMap((result) => (result.status === 'fulfilled' ? result.value : []));
  }
}
```

</CodeGroup>
