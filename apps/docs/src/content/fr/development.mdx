export const metadata = {
  title: 'DÃ©veloppement',
  description:
    'Configurer pnpm-catalog-updates pour le dÃ©veloppement. Apprenez la structure du projet, le flux de travail de dÃ©veloppement et comment contribuer.',
};

# DÃ©veloppement

Configurez PCU pour le dÃ©veloppement et apprenez comment contribuer au projet. Ce guide couvre la configuration du projet, l'architecture et les flux de travail de dÃ©veloppement. {{ className: 'lead' }}

## PrÃ©requis

Avant de commencer Ã  dÃ©velopper PCU, assurez-vous d'avoir les outils requis :

<Note>Node.js >= 22.0.0 et pnpm >= 10.0.0 sont requis pour le dÃ©veloppement.</Note>

<CodeGroup>

```bash {{ title: 'VÃ©rifier les Versions' }}
node --version  # Devrait Ãªtre >= 22.0.0
pnpm --version  # Devrait Ãªtre >= 10.0.0
```

```bash {{ title: 'Installer les Outils' }}
# Installer Node.js via nvm (recommandÃ©)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 22
nvm use 22

# Installer pnpm
npm install -g pnpm@latest
```

</CodeGroup>

## Configuration du Projet

Cloner et configurer l'environnement de dÃ©veloppement :

<CodeGroup>

```bash {{ title: 'Cloner et Configurer' }}
# Cloner le dÃ©pÃ´t
git clone https://github.com/houko/pnpm-catalog-updates.git
cd pnpm-catalog-updates

# Installer les dÃ©pendances
pnpm install

# Construire le projet
pnpm build

# ExÃ©cuter les tests pour vÃ©rifier la configuration
pnpm test
```

```bash {{ title: 'Mode DÃ©veloppement' }}
# ExÃ©cuter en mode dÃ©veloppement
pnpm dev --help

# Construire en mode watch
pnpm build:watch

# ExÃ©cuter les tests en mode watch
pnpm test:watch
```

</CodeGroup>

## Architecture du Projet

PCU suit les principes d'architecture propre avec une sÃ©paration claire des prÃ©occupations :

```text
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ cli/                    # Couche application CLI
â”‚   â”‚   â”œâ”€â”€ src/cli/           # Interface CLI
â”‚   â”‚   â”‚   â”œâ”€â”€ commands/      # Gestionnaires de commandes
â”‚   â”‚   â”‚   â”œâ”€â”€ formatters/    # Formateurs de sortie
â”‚   â”‚   â”‚   â”œâ”€â”€ interactive/   # Invites interactives
â”‚   â”‚   â”‚   â”œâ”€â”€ themes/        # ThÃ¨mes de couleur
â”‚   â”‚   â”‚   â””â”€â”€ validators/    # Validation d'entrÃ©e
â”‚   â”‚   â””â”€â”€ bin/               # Binaires exÃ©cutables
â”‚   â””â”€â”€ docs/                  # Site de documentation
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ core/                  # Logique mÃ©tier principale
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ application/   # Services d'application
â”‚   â”‚       â”œâ”€â”€ domain/        # ModÃ¨le de domaine (DDD)
â”‚   â”‚       â””â”€â”€ infrastructure/# Couche infrastructure
â”‚   â””â”€â”€ utils/                 # Utilitaires partagÃ©s
â””â”€â”€ scripts/                   # Construction et dÃ©ploiement
```

### Couches d'Architecture

<Properties>
  <Property name="Couche CLI" type="apps/cli">
    Interface utilisateur, analyse de commandes, formatage de sortie
  </Property>
  <Property name="Couche Application" type="packages/core/application">
    Orchestration de la logique mÃ©tier, cas d'usage
  </Property>
  <Property name="Couche Domaine" type="packages/core/domain">
    EntitÃ©s mÃ©tier principales, objets de valeur, interfaces de dÃ©pÃ´t
  </Property>
  <Property name="Couche Infrastructure" type="packages/core/infrastructure">
    Clients API externes, accÃ¨s au systÃ¨me de fichiers, implÃ©mentations de dÃ©pÃ´t
  </Property>
  <Property name="Couche Utilitaires" type="packages/utils">
    Utilitaires partagÃ©s, configuration, journalisation, gestion d'erreurs
  </Property>
</Properties>

## Flux de Travail de DÃ©veloppement

### Effectuer des Modifications

1. **CrÃ©er une branche de fonctionnalitÃ©** :

   ```bash
   git checkout -b feature/amazing-feature
   ```

2. **Effectuer vos modifications** en suivant les standards de codage

3. **Ajouter des tests** pour vos modifications :

   ```bash
   pnpm test:watch  # ExÃ©cuter les tests en mode watch
   ```

4. **S'assurer que les vÃ©rifications qualitÃ© passent** :

   ```bash
   pnpm lint        # VÃ©rifier le style de code
   pnpm typecheck   # VÃ©rification de type
   pnpm test        # ExÃ©cuter tous les tests
   ```

5. **Commiter vos modifications** :
   ```bash
   git commit -m 'feat: add amazing feature'
   ```

### StratÃ©gie de Test

PCU utilise une approche de test complÃ¨te :

<CodeGroup>

```bash {{ title: 'Tests Unitaires' }}
# ExÃ©cuter les tests unitaires
pnpm test

# ExÃ©cuter avec couverture
pnpm test:coverage

# Tester un package spÃ©cifique
pnpm --filter @pcu/core test
```

```bash {{ title: 'Tests E2E' }}
# ExÃ©cuter les tests de bout en bout
pnpm test:e2e

# Tester contre de vrais projets
pnpm test:e2e --project example-workspace
```

```bash {{ title: 'Tests d'IntÃ©gration' }}
# Tester les commandes CLI
pnpm test:cli

# Tester avec diffÃ©rentes versions Node
nvm use 18 && pnpm test
nvm use 20 && pnpm test
nvm use 22 && pnpm test
```

</CodeGroup>

### QualitÃ© du Code

PCU maintient des standards de qualitÃ© de code Ã©levÃ©s :

<CodeGroup>

```bash {{ title: 'Linting et Formatage' }}
# VÃ©rifier le style de code
pnpm lint

# Corriger les problÃ¨mes de linting
pnpm lint:fix

# Formater le code
pnpm format

# VÃ©rifier les types TypeScript
pnpm typecheck
```

```json {{ title: 'Standards de QualitÃ©' }}
{
  "coverage": {
    "statements": 85,
    "branches": 80,
    "functions": 85,
    "lines": 85
  },
  "lint": "ESLint avec rÃ¨gles TypeScript",
  "format": "Prettier avec config personnalisÃ©e",
  "types": "Configuration TypeScript stricte"
}
```

</CodeGroup>

## Ajouter des FonctionnalitÃ©s

### CrÃ©er de Nouvelles Commandes

1. **CrÃ©er un gestionnaire de commande** dans `apps/cli/src/cli/commands/` :

<CodeGroup>

```typescript {{ title: 'newCommand.ts' }}
import { Command } from 'commander';
import { GlobalOptions } from '../options';

export function createNewCommand(): Command {
  return new Command('new')
    .description('Description de la nouvelle commande')
    .option('-f, --format <type>', 'Format de sortie', 'table')
    .action(async (options: NewCommandOptions) => {
      // ImplÃ©mentation de la commande
    });
}

interface NewCommandOptions extends GlobalOptions {
  format: string;
}
```

```typescript {{ title: 'Enregistrer la Commande' }}
// Dans apps/cli/src/cli/index.ts
import { createNewCommand } from './commands/newCommand';

program.addCommand(createNewCommand());
```

</CodeGroup>

2. **Ajouter la logique mÃ©tier** dans `packages/core/src/application/services/`

3. **CrÃ©er des tests** pour la CLI et la logique principale

4. **Mettre Ã  jour la documentation**

### Ajouter de Nouveaux Formats de Sortie

1. **CrÃ©er un formateur** dans `apps/cli/src/cli/formatters/` :

```typescript {{ title: 'xmlFormatter.ts' }}
import { OutputFormatter, FormattedOutput } from './outputFormatter';

export class XmlFormatter implements OutputFormatter {
  format(data: any): FormattedOutput {
    // Logique de formatage XML
    return {
      content: xmlContent,
      type: 'xml',
    };
  }
}
```

2. **Enregistrer le formateur** dans le registre principal des formateurs

3. **Ajouter des tests** et **mettre Ã  jour la documentation**

## Directives de Contribution

### Convention de Message de Commit

PCU utilise [Conventional Commits](https://conventionalcommits.org/) :

<CodeGroup>

```bash {{ title: 'Types de Commit' }}
feat: Une nouvelle fonctionnalitÃ©
fix: Une correction de bug
docs: Modifications de documentation uniquement
style: Modifications de style de code (formatage, etc)
refactor: Modification de code qui ne corrige pas un bug ni n'ajoute une fonctionnalitÃ©
test: Ajout de tests manquants ou correction de tests existants
chore: Modifications du processus de construction ou d'outils auxiliaires
```

```bash {{ title: 'Exemples' }}
feat: add support for custom registries
fix: handle network timeouts gracefully
docs: update configuration examples
test: add tests for package filtering
```

</CodeGroup>

### Processus de Pull Request

1. **Forker le dÃ©pÃ´t** et crÃ©er une branche de fonctionnalitÃ©
2. **Effectuer vos modifications** en suivant le flux de travail de dÃ©veloppement
3. **S'assurer que tous les tests passent** et que les vÃ©rifications qualitÃ© rÃ©ussissent
4. **Mettre Ã  jour la documentation** si nÃ©cessaire
5. **Soumettre une pull request** avec :
   - Description claire des modifications
   - Lien vers les issues liÃ©es
   - Captures d'Ã©cran pour les modifications UI
   - Notes sur les changements cassants si applicable

### Liste de VÃ©rification de RÃ©vision de Code

1. Tous les tests passent
2. Couverture de code maintenue (>85%)
3. Types TypeScript corrects
4. Style de code conforme aux standards du projet
5. Documentation mise Ã  jour
6. Changements cassants documentÃ©s
7. Impact sur les performances considÃ©rÃ©

## DÃ©bogage

### DÃ©bogage de DÃ©veloppement

<CodeGroup>

```bash {{ title: 'DÃ©boguer les Commandes CLI' }}
# DÃ©boguer avec l'inspecteur Node.js
node --inspect-brk ./apps/cli/bin/pcu.js --help

# DÃ©boguer avec VS Code
# Utiliser la configuration de lancement dans .vscode/launch.json
```

```bash {{ title: 'Journalisation Verbose' }}
# Activer la journalisation de dÃ©bogage
DEBUG=pcu:* pnpm dev --verbose

# DÃ©boguer des modules spÃ©cifiques
DEBUG=pcu:core,pcu:cli pcu -c
```

</CodeGroup>

### DÃ©bogage de Test

```bash
# DÃ©boguer un test spÃ©cifique
npm test -- --grep "specific test name"

# DÃ©boguer avec l'inspecteur Node
node --inspect-brk node_modules/.bin/vitest run
```

## Construction et Publication

### Test Local

<CodeGroup>

```bash {{ title: 'Tester la Construction Locale' }}
# Construire et tester localement
pnpm build
pnpm --filter @pcu/cli start --help

# Tester l'installation
npm pack apps/cli
npm install -g pcu-*.tgz
```

```bash {{ title: 'Tester dans un Projet Exemple' }}
# Utiliser l'espace de travail exemple
cd apps/example
pcu -c
pcu -u --dry-run
```

</CodeGroup>

### Processus de Release

1. **Mettre Ã  jour la version** en utilisant changesets :

   ```bash
   pnpm changeset
   pnpm changeset version
   ```

2. **Construire et tester** :

   ```bash
   pnpm build
   pnpm test
   pnpm test:e2e
   ```

3. **Publier** (mainteneurs uniquement) :
   ```bash
   pnpm publish -r
   ```

## Obtenir de l'Aide

- ğŸ“– **Documentation** : Consultez cette documentation pour des guides dÃ©taillÃ©s
- ğŸ› **Issues** : Signaler des bugs via [GitHub Issues](https://github.com/houko/pnpm-catalog-updates/issues)
- ğŸ’¬ **Discussions** : Poser des questions dans [GitHub Discussions](https://github.com/houko/pnpm-catalog-updates/discussions)
- ğŸ”§ **DÃ©veloppement** : Rejoindre les discussions de dÃ©veloppement dans les issues et PRs

---

## DÃ©tails d'Architecture AvancÃ©s

### ModÃ¨le de Domaine Principal

BasÃ© sur les principes de Domain-Driven Design (DDD), le domaine principal de PCU inclut :

<CodeGroup>

```typescript {{ title: 'EntitÃ©s de Domaine' }}
// packages/core/src/domain/entities/
â”œâ”€â”€ catalog.ts          // Racine d'agrÃ©gat de catalogue
â”œâ”€â”€ package.ts          // EntitÃ© package
â””â”€â”€ workspace.ts        // Racine d'agrÃ©gat d'espace de travail

// Concepts de domaine clÃ©s :
interface Catalog {
  readonly id: CatalogId;
  readonly name: string;
  packages: PackageCollection;
  addPackage(packageInfo: Package): void;
  updatePackage(name: string, version: Version): void;
}

interface Package {
  readonly name: string;
  readonly currentVersion: Version;
  readonly latestVersion: Version;
  readonly updateType: UpdateType;
}
```

```typescript {{ title: 'Objets de Valeur' }}
// packages/core/src/domain/value-objects/
â”œâ”€â”€ version.ts           // Gestion de version sÃ©mantique
â”œâ”€â”€ workspacePath.ts     # Validation de chemin
â”œâ”€â”€ workspaceConfig.ts   // Objet de configuration
â””â”€â”€ catalogCollection.ts // Gestion de collection

// Les objets de valeur immuables assurent l'intÃ©gritÃ© des donnÃ©es
class Version {
  constructor(private readonly value: string) {
    if (!this.isValid(value)) {
      throw new InvalidVersionError(value);
    }
  }

  toString(): string { return this.value; }
  compare(other: Version): number { /* comparaison semver */ }
}
```

</CodeGroup>

### Architecture de Couche de Service

La couche application orchestre la logique mÃ©tier Ã  travers les services :

<CodeGroup>

```typescript {{ title: 'Services d'Application' }}
// packages/core/src/application/services/
â”œâ”€â”€ catalogUpdateService.ts  // Orchestration principale
â””â”€â”€ workspaceService.ts      // OpÃ©rations d'espace de travail

// ResponsabilitÃ©s des services :
class CatalogUpdateService {
  async checkForUpdates(options: CheckOptions): Promise<UpdateReport>;
  async updateCatalog(options: UpdateOptions): Promise<UpdateResult>;
  async analyzeImpact(catalog: string, package: string): Promise<ImpactAnalysis>;
}
```

```typescript {{ title: 'Couche Infrastructure' }}
// packages/core/src/infrastructure/
â”œâ”€â”€ external-services/
â”‚   â””â”€â”€ npmRegistryService.ts   // Client API NPM
â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ fileWorkspaceRepository.ts  // Persistance systÃ¨me de fichiers
â”œâ”€â”€ cache/
â”‚   â””â”€â”€ cache.ts                # SystÃ¨me de cache avancÃ©
â””â”€â”€ utils/
    â””â”€â”€ npmrcParser.ts          # Analyse de configuration

// L'infrastructure implÃ©mente les interfaces de domaine :
class FileWorkspaceRepository implements WorkspaceRepository {
  async findWorkspace(path: string): Promise<Workspace | null>;
  async saveWorkspace(workspace: Workspace): Promise<void>;
}
```

</CodeGroup>

### Conception de Couche CLI

La couche CLI fournit une interface propre au domaine principal :

<CodeGroup>

```typescript {{ title: 'Structure de Commande' }}
// apps/cli/src/cli/commands/
â”œâ”€â”€ checkCommand.ts     // ImplÃ©mentation commande check
â”œâ”€â”€ updateCommand.ts    // Commande update avec validation
â”œâ”€â”€ analyzeCommand.ts   // Commande d'analyse d'impact
â”œâ”€â”€ workspaceCommand.ts # Gestion d'espace de travail
â”œâ”€â”€ themeCommand.ts     // Configuration de thÃ¨me
â”œâ”€â”€ securityCommand.ts  // Scan de sÃ©curitÃ©
â””â”€â”€ initCommand.ts      // Initialisation d'espace de travail

// Chaque commande suit des patterns cohÃ©rents :
export class CheckCommand {
  constructor(
    private readonly catalogService: CatalogUpdateService,
    private readonly validator: CommandValidator,
    private readonly formatter: OutputFormatter
  ) {}

  async execute(options: CheckCommandOptions): Promise<void> {
    const validation = this.validator.validateCheckOptions(options);
    if (!validation.isValid) {
      throw new ValidationError(validation.errors);
    }

    const result = await this.catalogService.checkForUpdates(options);
    const formatted = this.formatter.format(result, options.format);
    console.log(formatted);
  }
}
```

```typescript {{ title: 'FonctionnalitÃ©s CLI AvancÃ©es' }}
// apps/cli/src/cli/
â”œâ”€â”€ validators/
â”‚   â””â”€â”€ commandValidator.ts    # Validation d'entrÃ©e avec suggestions
â”œâ”€â”€ interactive/
â”‚   â””â”€â”€ interactivePrompts.ts  # Invites intelligentes avec auto-complÃ©tion
â”œâ”€â”€ themes/
â”‚   â””â”€â”€ colorTheme.ts          # SystÃ¨me de thÃ¨me complet
â””â”€â”€ formatters/
    â””â”€â”€ outputFormatter.ts     # Formats de sortie multiples

// FonctionnalitÃ©s interactives :
class InteractivePrompts {
  async selectPackages(packages: Package[]): Promise<string[]>;
  async confirmUpdates(updates: Update[]): Promise<boolean>;
  async configurationWizard(): Promise<Configuration>;
}
```

</CodeGroup>

### Architecture de Test

StratÃ©gie de test complÃ¨te Ã  travers toutes les couches :

<CodeGroup>

```bash {{ title: 'Structure de Test' }}
â”œâ”€â”€ packages/core/src/**/__tests__/     # Tests unitaires
â”œâ”€â”€ packages/utils/src/**/__tests__/    # Tests d'utilitaires
â”œâ”€â”€ apps/cli/src/**/__tests__/         # Tests unitaires CLI
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ e2e/                          # Tests de bout en bout
â”‚   â”œâ”€â”€ integration/                  # Tests d'intÃ©gration
â”‚   â””â”€â”€ fixtures/                     # Fixtures de test
â””â”€â”€ .github/workflows/
    â””â”€â”€ test.yml                      # Pipeline de test CI
```

```typescript {{ title: 'Patterns de Test' }}
// Tests de couche domaine
describe('Catalog', () => {
  it('should update package version', () => {
    const catalog = new Catalog('default');
    const package = new Package('react', '18.0.0', '18.2.0');

    catalog.addPackage(package);
    catalog.updatePackage('react', new Version('18.2.0'));

    expect(catalog.getPackage('react').currentVersion.toString()).toBe('18.2.0');
  });
});

// Tests d'intÃ©gration CLI
describe('CheckCommand', () => {
  it('should handle network errors gracefully', async () => {
    const mockService = createMockCatalogService();
    mockService.checkForUpdates.mockRejectedValue(new NetworkError());

    const command = new CheckCommand(mockService);

    await expect(command.execute({})).rejects.toThrow('Network error occurred');
  });
});
```

</CodeGroup>

### ConsidÃ©rations de Performance

PCU est optimisÃ© pour les performances dans les grands monorepos :

<CodeGroup>

```typescript {{ title: 'StratÃ©gie de Cache' }}
// Le cache intelligent rÃ©duit les appels API
class Cache<T> {
  constructor(
    private readonly options: {
      ttl: number; // DurÃ©e de vie
      maxSize: number; // Limite mÃ©moire
      persistToDisk: boolean; // Cache fichier
      strategy: 'lru' | 'fifo' | 'lfu'; // StratÃ©gie d'Ã©viction
    }
  ) {}

  async get(key: string): Promise<T | null>;
  async set(key: string, value: T): Promise<void>;
  getStats(): CacheStats; // Taux de succÃ¨s, utilisation mÃ©moire
}
```

```typescript {{ title: 'Traitement Concurrent' }}
// Traitement parallÃ¨le pour de meilleures performances
class NpmRegistryService {
  constructor(private readonly concurrency: number = 5) {}

  async getPackageInfo(names: string[]): Promise<PackageInfo[]> {
    // Traiter les packages par lots avec concurrence contrÃ´lÃ©e
    const batches = chunk(names, this.concurrency);
    const results = await Promise.allSettled(batches.map((batch) => this.processBatch(batch)));

    return results.flatMap((result) => (result.status === 'fulfilled' ? result.value : []));
  }
}
```

</CodeGroup>
